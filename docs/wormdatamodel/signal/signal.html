<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>wormdatamodel.signal.signal API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wormdatamodel.signal.signal</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Authors: Milena Chakraverti-Wuerthwein and Francesco Randi

import numpy as np
import matplotlib.pyplot as plt
import mistofrutta.struct.irrarray as irrarray
import wormdatamodel as wormdm
from copy import deepcopy as deepcopy
import warnings
import sys

class Signal:
    &#39;&#39;&#39;Class representing signal extracted from recording. It supports irregular
    striding of the signal, useful for recordings with associated events, like
    optogenetics stimulations. The metadata about the irregular strides can be 
    obtained via the recording.get_events() method.
    
    The class provides some preprocessing functionalities, like 
    nan-interpolation, smoothing, and in the future will provide photobleaching
    correction, with the goal of abstracting all this away from the scripts
    analysing the signal.    
    &#39;&#39;&#39;

    nan_mask = np.zeros(1) # where nans
    data = np.empty((0,0)); # data array; either ndarray or irrarray
    info = [];
    whichSkip = dict(zip([],[])); # which strides should be ignored
    
    def __init__(self,data,info,strides = [], strideNames = [], strideSkip = [], preprocess = True):
        &#39;&#39;&#39;Constructor for the class. 
        
        Parameters
        ----------
        data: numpy array
            2D array containing the data. The outermost axis has to be the one
            that gets strided irregularly.
        info: dict
            Dictionary containing the metadata about how the signal has been
            extracted from the frames.
        strides: list of numpy arrays (optional)
            Usually, the ones returned from recording.get_events().
            See documentation for the irregular array. Default: empty.
        strideNames: list of strings (optional)
            See documentation for the irregular array. Default: empty.
        strideSkip: list of integers (optional)
            Number of strides to skip at the beginning. Default: empty.
        preprocess: bool
            Apply the preprocessing to the signal. Default: True.        
        &#39;&#39;&#39;
        
        NS = 4; # smoothing parameter
        
        self.data = data;
        self.info = info;
        self.nan_mask = np.isnan(self.data)
        
        if preprocess:
            # interpolate
            self.data = self.interpolate_nans();
            self.data = self.smooth(NS);
        
        # strides option allows you to construct an irregular array
        self.whichSkip = dict(zip(strideNames,strideSkip))
        if len(strides) &gt; 0:
            
            # make sure that strideNames matches in size with the number stride arrays provided
            if len(strideNames) &gt; len(strides):
                warnings.warn(&#39;More stride names specified than stride arrays. Unused have been cut.&#39;);
                strideNames = strideNames[0:len(strides)]
            elif len(strideNames) &lt; len(strides):
                warnings.warn(&#39;Fewer stride names specified than stride arrays. &#39; + 
                &#39;Additional strides have been set to the default (thing_0, thing_1, ...).&#39;);
                for i in np.arange(len(strides) - len(strideNames)):
                    strideNames += [&#39;thing_&#39; + str(i)]
            
            data_uncut = np.copy(self.data)
            self.data = irrarray(data_uncut, strides, strideNames=strideNames)
            
            mask_uncut = np.copy(self.nan_mask)
            self.nan_mask = irrarray(mask_uncut, strides, strideNames=strideNames)
    
    
    @classmethod
    def from_file(cls,folder,filename,*args,**kwargs):
        &#39;&#39;&#39;Creates an instance of the class loading the data from file.
        
        Parameters
        ----------
        folder: str
            Folder containing the file.
        filename: str
            Name of the file containing the signal array.
        *args, **kwargs
            Any other parameter to be passed to the constructor.
        &#39;&#39;&#39;
            
        # read in data; rows = time, columns = neuron
        data, info = wormdm.signal.from_file(folder,filename)
        # adjusting the shape so that even if only one neuron, still has &#34;columns&#34;
        try:
            data.shape[1]
            
        except:
            data = np.copy(np.reshape(data,(data.shape[0],1)))
        
        return cls(data,info,*args,**kwargs)
    
    ##### Pre-processing Functions #####
    
    def interpolate_nans(self):
        &#39;&#39;&#39;Replace nans with an interpolated value.&#39;&#39;&#39;
        interpolated = np.copy(self.data)
        
        for i in np.arange(self.data.shape[1]):
            # nans: location of nans
            # x: function that finds the non-zero entries
            nans, x = self.nan_mask[:,i], lambda z: z.nonzero()[0]
            try:
                interpolated[nans,i] = np.interp(x(nans), x(~nans), self.data[~nans,i])
            except:
                pass
        
        return interpolated
    
    def smooth(self, n):
        &#39;&#39;&#39;Smooth the signal with a rectangular filter.
        
        Parameters
        ----------
        n: int
            Width of the rectangular filter.        
        &#39;&#39;&#39;
        sm = np.ones(n)/n
        smoothed = np.copy(self.data)    
        
        for i in np.arange(self.data.shape[1]):
            smoothed[:,i] = np.convolve(self.data[:,i],sm,mode=&#34;same&#34;)
        
        return smoothed
        
    ##### Additional Capabilities #####
    
    def trim(self,strideName, adjust = None):
        &#39;&#39;&#39;If the signal is an irregular array, trim it to make the regularize
        the stride along the irregular axis.
        
        Parameters
        ----------
        strideName: string
            Name of the stride along which to trim.
        adjust: int
            Number of points to average to subtract the background.
            
        Returns
        -------
        trimmed: irregular array
            Irregular array that has now effectively a regular stride. 
            trimmed.data can now be copied and reshaped into a multidimensional
            numpy array.        
        &#39;&#39;&#39;
        
        try:
            start = self.data.firstIndex[strideName];
            strideLength = np.diff(start);
        except:
            print(&#39;Trim unsuccesful, signal has no strides by the name &#34;&#39; + strideName + &#39;&#34;.&#39;)
            sys.exit();
        
        mask = np.ones(strideLength.shape, dtype = bool);
        mask[self.whichSkip[strideName]] = False;
        min_len = np.min(strideLength[mask])
        
        temp_data = np.ones((1,self.data.shape[1]))
        temp_nan = np.ones((1,self.data.shape[1]))
        
        for stPt in start[np.append(mask,False)]:
            if adjust == None: adj = 0;
            else: adj = np.mean(self.data[stPt:stPt+adjust],axis=0);
            temp_data = np.vstack((temp_data,self.data[stPt:stPt+min_len]-adj));
            temp_nan = np.vstack((temp_nan,self.nan_mask[stPt:stPt+min_len]));
        temp_data = np.copy(temp_data[1:])
        temp_nan = np.copy(temp_nan[1:])
        
        temp_strides = (np.ones_like(strideLength[mask])*min_len)
        #temp_strides = (np.ones_like(strideLength)*min_len)
        # print(&#39;trimmed strides&#39;,temp_strides)
        
        trimmed = self.copy()
        trimmed.data = irrarray(temp_data, [temp_strides], strideNames=[strideName])
        trimmed.nan_mask = irrarray(temp_nan, [temp_strides], strideNames=[strideName])
        trimmed.whichSkip = dict({strideName : []});
        
        return trimmed
        
    def average(self,strideName, adjust = None):
        &#39;&#39;&#39;Average the signal over an irregular stride. The function first
        obtains the trimmed version of the array along that stride, subtracts
        the background, and averages across the events.
        
        Parameters
        ----------
        strideName: str
            Name of the irregular stride.
        adjust: int
            Number of points to average for the background subtraction.
            
        Returns
        -------
        avg: numpy array
            Array containing the average over the specified stride.
        
        &#39;&#39;&#39;
        
        # adjust tells you how many points to average as a baseline to subtract out
        try:
            trimmed = self.trim(strideName, adjust = adjust);
        except:
            print(&#39;Average unsuccessful, signal has no strides by the name &#34;&#39; + strideName + &#39;&#34;.&#39;)
            sys.exit();
        length = trimmed.data.firstIndex[strideName][1];
        numStrides = trimmed.data.firstIndex[strideName].size-1
        temp = np.reshape(trimmed.data,(numStrides,length,trimmed.data.shape[1])) 
        avg = np.mean(temp,axis = 0)
        return avg
    
    ##### Underbelly Functions #####
    
    def copy(self):
        return deepcopy(self)
        
    def __getitem__(self, i):
        &#39;&#39;&#39;Allow for direct indexing of the class to access the data.&#39;&#39;&#39;
        return self.data.__getitem__(i)
        
    def __setitem__(self, i, value):
        &#39;&#39;&#39;Allow for direct indexing of the class to write in the data.&#39;&#39;&#39;
        self.data.__setitem__(i,value)
        
    def __call__(self, *args, **kwargs):
        &#39;&#39;&#39;Upon call, use the __call__ method of the data irrarray.&#39;&#39;&#39;
        return self.data.__call__(*args, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wormdatamodel.signal.signal.Signal"><code class="flex name class">
<span>class <span class="ident">Signal</span></span>
<span>(</span><span>data, info, strides=[], strideNames=[], strideSkip=[], preprocess=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing signal extracted from recording. It supports irregular
striding of the signal, useful for recordings with associated events, like
optogenetics stimulations. The metadata about the irregular strides can be
obtained via the recording.get_events() method.</p>
<p>The class provides some preprocessing functionalities, like
nan-interpolation, smoothing, and in the future will provide photobleaching
correction, with the goal of abstracting all this away from the scripts
analysing the signal.
</p>
<p>Constructor for the class. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>2D array containing the data. The outermost axis has to be the one
that gets strided irregularly.</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing the metadata about how the signal has been
extracted from the frames.</dd>
<dt><strong><code>strides</code></strong> :&ensp;<code>list</code> of <code>numpy arrays (optional)</code></dt>
<dd>Usually, the ones returned from recording.get_events().
See documentation for the irregular array. Default: empty.</dd>
<dt><strong><code>strideNames</code></strong> :&ensp;<code>list</code> of <code>strings (optional)</code></dt>
<dd>See documentation for the irregular array. Default: empty.</dd>
<dt><strong><code>strideSkip</code></strong> :&ensp;<code>list</code> of <code>integers (optional)</code></dt>
<dd>Number of strides to skip at the beginning. Default: empty.</dd>
<dt><strong><code>preprocess</code></strong> :&ensp;<code>bool</code></dt>
<dd>Apply the preprocessing to the signal. Default: True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signal:
    &#39;&#39;&#39;Class representing signal extracted from recording. It supports irregular
    striding of the signal, useful for recordings with associated events, like
    optogenetics stimulations. The metadata about the irregular strides can be 
    obtained via the recording.get_events() method.
    
    The class provides some preprocessing functionalities, like 
    nan-interpolation, smoothing, and in the future will provide photobleaching
    correction, with the goal of abstracting all this away from the scripts
    analysing the signal.    
    &#39;&#39;&#39;

    nan_mask = np.zeros(1) # where nans
    data = np.empty((0,0)); # data array; either ndarray or irrarray
    info = [];
    whichSkip = dict(zip([],[])); # which strides should be ignored
    
    def __init__(self,data,info,strides = [], strideNames = [], strideSkip = [], preprocess = True):
        &#39;&#39;&#39;Constructor for the class. 
        
        Parameters
        ----------
        data: numpy array
            2D array containing the data. The outermost axis has to be the one
            that gets strided irregularly.
        info: dict
            Dictionary containing the metadata about how the signal has been
            extracted from the frames.
        strides: list of numpy arrays (optional)
            Usually, the ones returned from recording.get_events().
            See documentation for the irregular array. Default: empty.
        strideNames: list of strings (optional)
            See documentation for the irregular array. Default: empty.
        strideSkip: list of integers (optional)
            Number of strides to skip at the beginning. Default: empty.
        preprocess: bool
            Apply the preprocessing to the signal. Default: True.        
        &#39;&#39;&#39;
        
        NS = 4; # smoothing parameter
        
        self.data = data;
        self.info = info;
        self.nan_mask = np.isnan(self.data)
        
        if preprocess:
            # interpolate
            self.data = self.interpolate_nans();
            self.data = self.smooth(NS);
        
        # strides option allows you to construct an irregular array
        self.whichSkip = dict(zip(strideNames,strideSkip))
        if len(strides) &gt; 0:
            
            # make sure that strideNames matches in size with the number stride arrays provided
            if len(strideNames) &gt; len(strides):
                warnings.warn(&#39;More stride names specified than stride arrays. Unused have been cut.&#39;);
                strideNames = strideNames[0:len(strides)]
            elif len(strideNames) &lt; len(strides):
                warnings.warn(&#39;Fewer stride names specified than stride arrays. &#39; + 
                &#39;Additional strides have been set to the default (thing_0, thing_1, ...).&#39;);
                for i in np.arange(len(strides) - len(strideNames)):
                    strideNames += [&#39;thing_&#39; + str(i)]
            
            data_uncut = np.copy(self.data)
            self.data = irrarray(data_uncut, strides, strideNames=strideNames)
            
            mask_uncut = np.copy(self.nan_mask)
            self.nan_mask = irrarray(mask_uncut, strides, strideNames=strideNames)
    
    
    @classmethod
    def from_file(cls,folder,filename,*args,**kwargs):
        &#39;&#39;&#39;Creates an instance of the class loading the data from file.
        
        Parameters
        ----------
        folder: str
            Folder containing the file.
        filename: str
            Name of the file containing the signal array.
        *args, **kwargs
            Any other parameter to be passed to the constructor.
        &#39;&#39;&#39;
            
        # read in data; rows = time, columns = neuron
        data, info = wormdm.signal.from_file(folder,filename)
        # adjusting the shape so that even if only one neuron, still has &#34;columns&#34;
        try:
            data.shape[1]
            
        except:
            data = np.copy(np.reshape(data,(data.shape[0],1)))
        
        return cls(data,info,*args,**kwargs)
    
    ##### Pre-processing Functions #####
    
    def interpolate_nans(self):
        &#39;&#39;&#39;Replace nans with an interpolated value.&#39;&#39;&#39;
        interpolated = np.copy(self.data)
        
        for i in np.arange(self.data.shape[1]):
            # nans: location of nans
            # x: function that finds the non-zero entries
            nans, x = self.nan_mask[:,i], lambda z: z.nonzero()[0]
            try:
                interpolated[nans,i] = np.interp(x(nans), x(~nans), self.data[~nans,i])
            except:
                pass
        
        return interpolated
    
    def smooth(self, n):
        &#39;&#39;&#39;Smooth the signal with a rectangular filter.
        
        Parameters
        ----------
        n: int
            Width of the rectangular filter.        
        &#39;&#39;&#39;
        sm = np.ones(n)/n
        smoothed = np.copy(self.data)    
        
        for i in np.arange(self.data.shape[1]):
            smoothed[:,i] = np.convolve(self.data[:,i],sm,mode=&#34;same&#34;)
        
        return smoothed
        
    ##### Additional Capabilities #####
    
    def trim(self,strideName, adjust = None):
        &#39;&#39;&#39;If the signal is an irregular array, trim it to make the regularize
        the stride along the irregular axis.
        
        Parameters
        ----------
        strideName: string
            Name of the stride along which to trim.
        adjust: int
            Number of points to average to subtract the background.
            
        Returns
        -------
        trimmed: irregular array
            Irregular array that has now effectively a regular stride. 
            trimmed.data can now be copied and reshaped into a multidimensional
            numpy array.        
        &#39;&#39;&#39;
        
        try:
            start = self.data.firstIndex[strideName];
            strideLength = np.diff(start);
        except:
            print(&#39;Trim unsuccesful, signal has no strides by the name &#34;&#39; + strideName + &#39;&#34;.&#39;)
            sys.exit();
        
        mask = np.ones(strideLength.shape, dtype = bool);
        mask[self.whichSkip[strideName]] = False;
        min_len = np.min(strideLength[mask])
        
        temp_data = np.ones((1,self.data.shape[1]))
        temp_nan = np.ones((1,self.data.shape[1]))
        
        for stPt in start[np.append(mask,False)]:
            if adjust == None: adj = 0;
            else: adj = np.mean(self.data[stPt:stPt+adjust],axis=0);
            temp_data = np.vstack((temp_data,self.data[stPt:stPt+min_len]-adj));
            temp_nan = np.vstack((temp_nan,self.nan_mask[stPt:stPt+min_len]));
        temp_data = np.copy(temp_data[1:])
        temp_nan = np.copy(temp_nan[1:])
        
        temp_strides = (np.ones_like(strideLength[mask])*min_len)
        #temp_strides = (np.ones_like(strideLength)*min_len)
        # print(&#39;trimmed strides&#39;,temp_strides)
        
        trimmed = self.copy()
        trimmed.data = irrarray(temp_data, [temp_strides], strideNames=[strideName])
        trimmed.nan_mask = irrarray(temp_nan, [temp_strides], strideNames=[strideName])
        trimmed.whichSkip = dict({strideName : []});
        
        return trimmed
        
    def average(self,strideName, adjust = None):
        &#39;&#39;&#39;Average the signal over an irregular stride. The function first
        obtains the trimmed version of the array along that stride, subtracts
        the background, and averages across the events.
        
        Parameters
        ----------
        strideName: str
            Name of the irregular stride.
        adjust: int
            Number of points to average for the background subtraction.
            
        Returns
        -------
        avg: numpy array
            Array containing the average over the specified stride.
        
        &#39;&#39;&#39;
        
        # adjust tells you how many points to average as a baseline to subtract out
        try:
            trimmed = self.trim(strideName, adjust = adjust);
        except:
            print(&#39;Average unsuccessful, signal has no strides by the name &#34;&#39; + strideName + &#39;&#34;.&#39;)
            sys.exit();
        length = trimmed.data.firstIndex[strideName][1];
        numStrides = trimmed.data.firstIndex[strideName].size-1
        temp = np.reshape(trimmed.data,(numStrides,length,trimmed.data.shape[1])) 
        avg = np.mean(temp,axis = 0)
        return avg
    
    ##### Underbelly Functions #####
    
    def copy(self):
        return deepcopy(self)
        
    def __getitem__(self, i):
        &#39;&#39;&#39;Allow for direct indexing of the class to access the data.&#39;&#39;&#39;
        return self.data.__getitem__(i)
        
    def __setitem__(self, i, value):
        &#39;&#39;&#39;Allow for direct indexing of the class to write in the data.&#39;&#39;&#39;
        self.data.__setitem__(i,value)
        
    def __call__(self, *args, **kwargs):
        &#39;&#39;&#39;Upon call, use the __call__ method of the data irrarray.&#39;&#39;&#39;
        return self.data.__call__(*args, **kwargs)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="wormdatamodel.signal.signal.Signal.nan_mask"><code class="name">var <span class="ident">nan_mask</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.whichSkip"><code class="name">var <span class="ident">whichSkip</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="wormdatamodel.signal.signal.Signal.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>folder, filename, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an instance of the class loading the data from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code></dt>
<dd>Folder containing the file.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the file containing the signal array.</dd>
<dt><strong><code>*args</code></strong>, <strong><code>**kwargs</code></strong></dt>
<dd>Any other parameter to be passed to the constructor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls,folder,filename,*args,**kwargs):
    &#39;&#39;&#39;Creates an instance of the class loading the data from file.
    
    Parameters
    ----------
    folder: str
        Folder containing the file.
    filename: str
        Name of the file containing the signal array.
    *args, **kwargs
        Any other parameter to be passed to the constructor.
    &#39;&#39;&#39;
        
    # read in data; rows = time, columns = neuron
    data, info = wormdm.signal.from_file(folder,filename)
    # adjusting the shape so that even if only one neuron, still has &#34;columns&#34;
    try:
        data.shape[1]
        
    except:
        data = np.copy(np.reshape(data,(data.shape[0],1)))
    
    return cls(data,info,*args,**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wormdatamodel.signal.signal.Signal.interpolate_nans"><code class="name flex">
<span>def <span class="ident">interpolate_nans</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace nans with an interpolated value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_nans(self):
    &#39;&#39;&#39;Replace nans with an interpolated value.&#39;&#39;&#39;
    interpolated = np.copy(self.data)
    
    for i in np.arange(self.data.shape[1]):
        # nans: location of nans
        # x: function that finds the non-zero entries
        nans, x = self.nan_mask[:,i], lambda z: z.nonzero()[0]
        try:
            interpolated[nans,i] = np.interp(x(nans), x(~nans), self.data[~nans,i])
        except:
            pass
    
    return interpolated</code></pre>
</details>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.smooth"><code class="name flex">
<span>def <span class="ident">smooth</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Smooth the signal with a rectangular filter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of the rectangular filter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth(self, n):
    &#39;&#39;&#39;Smooth the signal with a rectangular filter.
    
    Parameters
    ----------
    n: int
        Width of the rectangular filter.        
    &#39;&#39;&#39;
    sm = np.ones(n)/n
    smoothed = np.copy(self.data)    
    
    for i in np.arange(self.data.shape[1]):
        smoothed[:,i] = np.convolve(self.data[:,i],sm,mode=&#34;same&#34;)
    
    return smoothed</code></pre>
</details>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.trim"><code class="name flex">
<span>def <span class="ident">trim</span></span>(<span>self, strideName, adjust=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If the signal is an irregular array, trim it to make the regularize
the stride along the irregular axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strideName</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the stride along which to trim.</dd>
<dt><strong><code>adjust</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points to average to subtract the background.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>trimmed</code></strong> :&ensp;<code>irregular array</code></dt>
<dd>Irregular array that has now effectively a regular stride.
trimmed.data can now be copied and reshaped into a multidimensional
numpy array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim(self,strideName, adjust = None):
    &#39;&#39;&#39;If the signal is an irregular array, trim it to make the regularize
    the stride along the irregular axis.
    
    Parameters
    ----------
    strideName: string
        Name of the stride along which to trim.
    adjust: int
        Number of points to average to subtract the background.
        
    Returns
    -------
    trimmed: irregular array
        Irregular array that has now effectively a regular stride. 
        trimmed.data can now be copied and reshaped into a multidimensional
        numpy array.        
    &#39;&#39;&#39;
    
    try:
        start = self.data.firstIndex[strideName];
        strideLength = np.diff(start);
    except:
        print(&#39;Trim unsuccesful, signal has no strides by the name &#34;&#39; + strideName + &#39;&#34;.&#39;)
        sys.exit();
    
    mask = np.ones(strideLength.shape, dtype = bool);
    mask[self.whichSkip[strideName]] = False;
    min_len = np.min(strideLength[mask])
    
    temp_data = np.ones((1,self.data.shape[1]))
    temp_nan = np.ones((1,self.data.shape[1]))
    
    for stPt in start[np.append(mask,False)]:
        if adjust == None: adj = 0;
        else: adj = np.mean(self.data[stPt:stPt+adjust],axis=0);
        temp_data = np.vstack((temp_data,self.data[stPt:stPt+min_len]-adj));
        temp_nan = np.vstack((temp_nan,self.nan_mask[stPt:stPt+min_len]));
    temp_data = np.copy(temp_data[1:])
    temp_nan = np.copy(temp_nan[1:])
    
    temp_strides = (np.ones_like(strideLength[mask])*min_len)
    #temp_strides = (np.ones_like(strideLength)*min_len)
    # print(&#39;trimmed strides&#39;,temp_strides)
    
    trimmed = self.copy()
    trimmed.data = irrarray(temp_data, [temp_strides], strideNames=[strideName])
    trimmed.nan_mask = irrarray(temp_nan, [temp_strides], strideNames=[strideName])
    trimmed.whichSkip = dict({strideName : []});
    
    return trimmed</code></pre>
</details>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.average"><code class="name flex">
<span>def <span class="ident">average</span></span>(<span>self, strideName, adjust=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Average the signal over an irregular stride. The function first
obtains the trimmed version of the array along that stride, subtracts
the background, and averages across the events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strideName</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the irregular stride.</dd>
<dt><strong><code>adjust</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points to average for the background subtraction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>avg</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Array containing the average over the specified stride.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average(self,strideName, adjust = None):
    &#39;&#39;&#39;Average the signal over an irregular stride. The function first
    obtains the trimmed version of the array along that stride, subtracts
    the background, and averages across the events.
    
    Parameters
    ----------
    strideName: str
        Name of the irregular stride.
    adjust: int
        Number of points to average for the background subtraction.
        
    Returns
    -------
    avg: numpy array
        Array containing the average over the specified stride.
    
    &#39;&#39;&#39;
    
    # adjust tells you how many points to average as a baseline to subtract out
    try:
        trimmed = self.trim(strideName, adjust = adjust);
    except:
        print(&#39;Average unsuccessful, signal has no strides by the name &#34;&#39; + strideName + &#39;&#34;.&#39;)
        sys.exit();
    length = trimmed.data.firstIndex[strideName][1];
    numStrides = trimmed.data.firstIndex[strideName].size-1
    temp = np.reshape(trimmed.data,(numStrides,length,trimmed.data.shape[1])) 
    avg = np.mean(temp,axis = 0)
    return avg</code></pre>
</details>
</dd>
<dt id="wormdatamodel.signal.signal.Signal.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return deepcopy(self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wormdatamodel.signal" href="index.html">wormdatamodel.signal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wormdatamodel.signal.signal.Signal" href="#wormdatamodel.signal.signal.Signal">Signal</a></code></h4>
<ul class="two-column">
<li><code><a title="wormdatamodel.signal.signal.Signal.from_file" href="#wormdatamodel.signal.signal.Signal.from_file">from_file</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.interpolate_nans" href="#wormdatamodel.signal.signal.Signal.interpolate_nans">interpolate_nans</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.smooth" href="#wormdatamodel.signal.signal.Signal.smooth">smooth</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.trim" href="#wormdatamodel.signal.signal.Signal.trim">trim</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.average" href="#wormdatamodel.signal.signal.Signal.average">average</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.copy" href="#wormdatamodel.signal.signal.Signal.copy">copy</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.nan_mask" href="#wormdatamodel.signal.signal.Signal.nan_mask">nan_mask</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.data" href="#wormdatamodel.signal.signal.Signal.data">data</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.info" href="#wormdatamodel.signal.signal.Signal.info">info</a></code></li>
<li><code><a title="wormdatamodel.signal.signal.Signal.whichSkip" href="#wormdatamodel.signal.signal.Signal.whichSkip">whichSkip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>