<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>wormdatamodel.signal.extraction API documentation</title>
<meta name="description" content="Functions related to the extraction of signal from the frames, coded as numpy
slicing and eventual weighting â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wormdatamodel.signal.extraction</code></h1>
</header>
<section id="section-intro">
<p>Functions related to the extraction of signal from the frames, coded as numpy
slicing and eventual weighting.</p>
<h2 id="imports">Imports</h2>
<p>numpy</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Functions related to the extraction of signal from the frames, coded as numpy
slicing and eventual weighting.

Imports
-------
numpy
&#39;&#39;&#39;

import numpy as np

def _generate_box_indices(Centers, box_size=(1,3,3), Box=np.array([]), 
                          shape=[None,None,None]):
    &#39;&#39;&#39;
    Generate indices for slicing of an array to extract the pixels in 
    boxes/windows of given size centered on Centers.
    
    Parameters
    ----------
    Centers: numpy array of integers
        Centers[center_index, coordinate]. Coordinates are in slicing order, not
        plotting order (i.e. z,y,x for volumetric images).
    box_size: list of odd integers (optional)
        Size of the boxes centered on each Center[i]. Again, coordinates are in
        slicing order. This parameter is used if the parameter Box is not passed
        or its shape[0] is 0. Default: (1,3,3)
    Box: numpy array (optional)
        Custom box. Default: np.array([])
    shape: list of integers
        Shape of the frames array.
        
    Returns
    -------
    Indices: numpy array of integers
        Indices over the frames representing the selected box repeated over the
        Centers. Use this array to slice the frames array to extract the pixels
        in the boxes around each center.        
    &#39;&#39;&#39;
    
    nCenters = Centers.shape[0]
    nCoord = Centers.shape[1]
    
    if Box.shape[0]==0:
        box_size = np.array(box_size)
        nElements = np.prod(box_size)
        if np.all(box_size==np.array([5,5,5])):
            Box = np.array([
                   [-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,\
                   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\
                   2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                   [-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,\
                   -2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,\
                   -2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2],
                   [-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,\
                   -2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,\
                   -2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2]
                         ])
        elif np.all(box_size==np.array([3,5,5])):
            Box = np.array([
                    [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2],
                    [-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2]
                          ])
        elif np.all(box_size==np.array([3,3,3])):
            Box = np.array([
                    [-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1],
                    [-1,-1,-1,0,0,0,1,1,1,-1,-1,-1,0,0,0,1,1,1,-1,-1,-1,0,0,0,1,1,1],
                    [-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1]
                    ])
        elif np.all(box_size==np.array([1,5,5])):
            Box = np.array([
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2],
                    [-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2]
                  ])
        elif np.all(box_size==np.array([1,3,3])):
            Box = np.array([
                    [0,0,0,0,0,0,0,0,0],
                    [-1,-1,-1,0,0,0,1,1,1],
                    [-1,0,1,-1,0,1,-1,0,1]
                  ])
        elif np.all(box_size==np.array([2,3,3])):
            Box = np.array([
                    [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1],
                    [-1,-1,-1,0,0,0,1,1,1,-1,-1,-1,0,0,0,1,1,1],
                    [-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1,-1,0,1]
                  ])
        elif np.all(box_size==np.array([1,1,1])):
            Box = np.array([[0],[0],[0]])
        elif np.all(box_size==np.array([3,3])):
            Box = np.array([
                    [-1,-1,-1,0,0,0,1,1,1],
                    [-1,0,1,-1,0,1,-1,0,1]
                  ])
        else:
            print(&#34;Box not implemented. see pp.signal._generate_box_indices&#34;)
            quit()
    else:
        nElements = Box.shape[1]
        
        
    &#39;&#39;&#39;#It was
    Centers_rep = np.repeat(Centers,nElements,axis=0).T.reshape((nCenters,nCoord,nElements))
    for coord in np.arange(nCoord):
        #This was the original one, but it&#39;s something weird (compare it with the reshaped shape above
        #Centers_rep[coord] += Box[coord]
    Indices = Centers_rep.reshape((nCoord,nCenters*nElements))
    &#39;&#39;&#39;
    
    Centers_rep = np.repeat(Centers,nElements,axis=0).T.reshape((nCoord,nCenters,nElements))
    
    for coord in np.arange(nCoord):
        Centers_rep += Box[:,None,:]
    
    Indices = Centers_rep.reshape((nCoord,nCenters*nElements))
    for q in np.arange(len(shape)):
        np.clip(Indices[q],0,shape[q]-1,Indices[q])
    
    return Indices
    
def _slice_array(Array, Indices):
    if len(Array.shape)==2:
        return Array[Indices[0],Indices[1]]
    elif len(Array.shape)==3:
        return Array[Indices[0],Indices[1],Indices[2]]
    
def extract(Frames, Neurons, method=&#34;box&#34;, framePixelOffset=0, **kwargs):
    &#39;&#39;&#39;Extracts the intensities in Frames at the position specified by Neurons.
    
    Parameters
    ----------
    Frames: numpy array
        Frames[z,y,x] images. Pass an already-sliced array if there are multiple
        channels. E.g., if you have Frames[z,ch,y,x], pass Frames[:,ch,...]
    Neurons: numpy array
        Neurons[n] zyx position at which to extract the intensity for neuron n.
    method: string, optional
        Method used to extract the intensities. Default: box.
    framePixelOffset: float, optional
        Offset of the pixel intensities possibly set by the camera. For the 
        Hamamatsu ORCA Flash it is approximately 100 for each pixel in the bin.
        Subtracted only here to avoid problems with integer arithmetic or 
        unnecessary conversions to float. Default: 0
    
    Returns
    -------
    Signal: numpy array
        Signal[n] gives the intensity of the neuron n.
    &#39;&#39;&#39;
    nNeuron = Neurons.shape[0]
    nCoord = Neurons.shape[1]
    
    if method==&#34;box&#34;:
        box_size = kwargs[&#39;box_size&#39;]
        nElements = np.prod(box_size)
        
        try: select_max = kwargs[&#39;select_max&#39;]
        except: select_max = False
        
        try: select_max_n = kwargs[&#39;select_max_n&#39;]
        except: select_max_n = 5
        
        if len(box_size)!=nCoord:
            print(&#34;Number of coordinates in Neuron coordinate and box_size &#34;+\
                &#34;don&#39;t match.&#34;)
            quit()

        # Generate indices for all the pixels in the boxes surrounding each neuron
        Indices = _generate_box_indices(Neurons, box_size, shape=Frames.shape)
        
        # Extract the values for each pixel
        Values = _slice_array(Frames,Indices).astype(np.float)-framePixelOffset
        
        # Reshape and sum values in each box
        Values = Values.reshape((nNeuron,nElements))
        np.clip(Values,0,None,Values)
        if not select_max:
            Signal = np.average(Values, axis=1)
        else:
            Signal = np.average(np.sort(Values,axis=1)[:,-select_max_n:],axis=1)
    
        return Signal
    elif method==&#34;weightedMask&#34;:
        weights = kwargs[&#39;weights&#39;]
        
        #hard coded indices - curvature extraction in neuronsegmentation-c
        nElements = 51
        Box = np.array([
            [-3,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,3],
            [0, -1,0,0,0,1, -2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2, -2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2, -2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2, -1,0,0,0,1, 0],
            [0,  0,1,0,1,0,  0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0,  0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0,  0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0,  0,1,0,1,0, 0]
            ])
            
        Box = []
        iz = -3
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,0])
        
        iz = -2
        Box.append([iz,-2,0])
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-2])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,0,2])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,1])
        Box.append([iz,2,0])
            
        for iz in np.array([-1,0,1]):
            Box.append([iz,-3,0])
            Box.append([iz,-2,-1])
            Box.append([iz,-2,0])
            Box.append([iz,-2,1])
            Box.append([iz,-1,-2])
            Box.append([iz,-1,-1])
            Box.append([iz,-1,0])
            Box.append([iz,-1,1])
            Box.append([iz,-1,2])
            Box.append([iz,0,-3])
            Box.append([iz,0,-2])
            Box.append([iz,0,-1])
            Box.append([iz,0,0])
            Box.append([iz,0,1])
            Box.append([iz,0,2])
            Box.append([iz,0,3])
            Box.append([iz,1,-2])
            Box.append([iz,1,-1])
            Box.append([iz,1,0])
            Box.append([iz,1,1])
            Box.append([iz,1,2])
            Box.append([iz,2,-1])
            Box.append([iz,2,0])
            Box.append([iz,2,1])
            Box.append([iz,3,0])
            
        iz = 2
        Box.append([iz,-2,0])
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-2])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,0,2])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,1])
        Box.append([iz,2,0])
        
        iz = 3
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,0])
        
        Box = np.array(Box).T
        
        TM = np.zeros((119,51))
        TM[0:9,0] = 1.0
        TM[-9:,-1] = 1.0
        
        for sab in [[9,1],[9+13+25+25+25,1+5+13+13+13]]:
            sa = sab[0]
            sb = sab[1]
            TM[sa+0,sb+0] = 1.0
            TM[sa+1,sb+0] = TM[sa+1,sb+1] = TM[sa+1,sb+2] = 1./3.
            TM[sa+2,sb+0] = TM[sa+2,sb+2] = 0.5
            TM[sa+3,sb+0] = TM[sa+3,sb+2] = TM[sa+3,sb+3] = 1./3.0
            TM[sa+4,sb+1] = 1.0
            TM[sa+5,sb+1] = TM[sa+5,sb+2] = 0.5
            TM[sa+6,sb+2] = 1.0
            TM[sa+7,sb+2] = TM[sa+7,sb+3] = 0.5
            TM[sa+8,sb+3] = 1.0
            TM[sa+9,sb+1] = TM[sa+9,sb+2] = TM[sa+9,sb+4] = 1./3.
            TM[sa+10,sb+2] = TM[sa+10,sb+4] = 0.5
            TM[sa+11,sb+3] = TM[sa+11,sb+2] = TM[sa+11,sb+4] = 1./3.
            TM[sa+12,sb+4] = 1.0
        
        for sab in [[9+13,1+5],[9+13+25,1+5+13],[9+13+25+25,1+5+13+13]]:
            sa = sab[0]
            sb = sab[1]
            TM[sa+0,sb+0] = 1.0
            TM[sa+1,sb+0] = TM[sa+1,sb+1] = TM[sa+1,sb+2] = 1./3.
            TM[sa+2,sb+0] = TM[sa+2,sb+2] = 0.5
            TM[sa+3,sb+0] = TM[sa+3,sb+2] = TM[sa+3,sb+3] = 1./3.
            TM[sa+4,sb+1] = TM[sa+4,sb+4] = TM[sa+4,sb+5] = 1./3.
            TM[sa+5,sb+1] = TM[sa+5,sb+2] = TM[sa+5,sb+5] = TM[sa+5,sb+6] = 0.25
            TM[sa+6,sb+2] = TM[sa+6,sb+6] = 0.5
            TM[sa+7,sb+2] = TM[sa+7,sb+3] = TM[sa+7,sb+6] = TM[sa+7,sb+7] = 0.25
            TM[sa+8,sb+3] = TM[sa+8,sb+7] = TM[sa+8,sb+8] = 1./3.
            TM[sa+9,sb+4] = 1.0
            TM[sa+10,sb+4] = TM[sa+10,sb+5] = 0.5
            TM[sa+11,sb+5] = TM[sa+11,sb+6] = 0.5
            TM[sa+12,sb+6] = 1.0
            TM[sa+13,sb+6] = TM[sa+13,sb+7] = 0.5
            TM[sa+14,sb+7] = TM[sa+14,sb+8] = 0.5
            TM[sa+15,sb+8] = 1.0
            TM[sa+16,sb+4] = TM[sa+16,sb+5] = TM[sa+16,sb+9] = 1./3.
            TM[sa+17,sb+5] = TM[sa+17,sb+6] = TM[sa+17,sb+9] = TM[sa+17,sb+10] = 0.25
            TM[sa+18,sb+6] = TM[sa+17,sb+10] = 0.5
            TM[sa+19,sb+6] = TM[sa+19,sb+7] = TM[sa+19,sb+10] = TM[sa+19,sb+11] = 1./3.
            TM[sa+20,sb+7] = TM[sa+20,sb+8] = TM[sa+20,sb+11] = 1./3.
            TM[sa+21,sb+9] = TM[sa+21,sb+10] = TM[sa+21,sb+12] = 1./3.
            TM[sa+22,sb+10] = TM[sa+22,sb+12] = 0.5
            TM[sa+23,sb+10] = TM[sa+23,sb+11] = TM[sa+23,sb+12] = 1./3.
            TM[sa+24,sb+12] = 1.0
        
        weights_new = np.zeros((weights.shape[0],119))
        for qu in np.arange(weights.shape[0]):
            weights_new[qu] = np.dot(TM,weights[qu])
        
        weights = weights_new
        nElements = 119
        
        # Generate indices based on box
        Indices = _generate_box_indices(Neurons, Box=Box, shape=Frames.shape)
        
        # Extract the values for each pixel
        Values = _slice_array(Frames,Indices).astype(np.float)
        
        # Reshape, multiply by weights and sum values in each box
        Values = Values.reshape((nNeuron,nElements))-framePixelOffset
        np.clip(Values,0,None,Values)
        wValues = Values*weights
        wValues /= np.sum(weights,axis=1)[:,None]
        
        try:
            Signal = np.average(Values, axis=1)
        except:
            print(Neurons)
            print(Indices)
            print(Values)
        
        return Signal
        
    elif method==&#34;weightedMask2d&#34;:
        weights = kwargs[&#39;weights&#39;]
        
        #hard coded indices - curvature extraction in neuronsegmentation-c
        nElements = 13
        Box = np.array([
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [-2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2],
            [0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0]
            ])
        
        # Generate indices based on box
        Indices = _generate_box_indices(Neurons, Box=Box, shape=Frames.shape)
        
        # Extract the values for each pixel
        Values = _slice_array(Frames,Indices).astype(np.float)
        
        # Reshape, multiply by weights and sum values in each box
        Values = Values.reshape((nNeuron,nElements))-framePixelOffset
        wValues = Values*weights
        wValues /= np.sum(weights,axis=1)[:,None]
        
        Signal = np.average(Values, axis=1) 
        
        return Signal
        
    elif method==&#34;fitSphere&#34;:
        # Doesn&#39;t really seem to help. Dropping it right now..
        
        # Right now this is fixed, it cannot be chosen
        box_size = (2,3,3)
        nElements = np.prod(box_size)
        
        # Generate indices based on box
        Indices = _generate_box_indices(Neurons, box_size)
        
        # Extract the values for each pixel, reshape, subtract camera offset
        Values = _slice_array(Frames,Indices).astype(np.float)
        Values = Values.reshape((nNeuron,nElements))-framePixelOffset
        
        # Calculate average signal at central plane and next one, to be used
        # to extract the radius of the neuron. Normalize them
        Y = np.empty((Values.shape[0],2))
        Y[:,0] = np.average(Values[:,0:9],axis=-1)
        Y[:,1] = np.average(Values[:,9:],axis=-1)
        
        Y[:,0] /= Y[:,0]
        Y[:,1] /= Y[:,1]
        
        # Calculate the radius of the neuron
        R = _sphere_radius(Y)
        
        # Extract signal and multiply by the radius
        Signal = np.average(Values[:,0:9], axis=1)*R
        
        return Signal
    
    else:
        print(&#34;Signal extraction method not implemented. See pp.signal.extract&#34;)
        quit()    
        
def _sphere_radius(y, dx=1.0):
    y0sq = y[:,0]**2
    return np.sqrt(y0sq + ((y0sq-y[:,1]**2-dx**2)/(2.0*dx))**2)
            </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wormdatamodel.signal.extraction.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>Frames, Neurons, method='box', framePixelOffset=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts the intensities in Frames at the position specified by Neurons.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Frames</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Frames[z,y,x] images. Pass an already-sliced array if there are multiple
channels. E.g., if you have Frames[z,ch,y,x], pass Frames[:,ch,&hellip;]</dd>
<dt><strong><code>Neurons</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Neurons[n] zyx position at which to extract the intensity for neuron n.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Method used to extract the intensities. Default: box.</dd>
<dt><strong><code>framePixelOffset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Offset of the pixel intensities possibly set by the camera. For the
Hamamatsu ORCA Flash it is approximately 100 for each pixel in the bin.
Subtracted only here to avoid problems with integer arithmetic or
unnecessary conversions to float. Default: 0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Signal</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Signal[n] gives the intensity of the neuron n.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(Frames, Neurons, method=&#34;box&#34;, framePixelOffset=0, **kwargs):
    &#39;&#39;&#39;Extracts the intensities in Frames at the position specified by Neurons.
    
    Parameters
    ----------
    Frames: numpy array
        Frames[z,y,x] images. Pass an already-sliced array if there are multiple
        channels. E.g., if you have Frames[z,ch,y,x], pass Frames[:,ch,...]
    Neurons: numpy array
        Neurons[n] zyx position at which to extract the intensity for neuron n.
    method: string, optional
        Method used to extract the intensities. Default: box.
    framePixelOffset: float, optional
        Offset of the pixel intensities possibly set by the camera. For the 
        Hamamatsu ORCA Flash it is approximately 100 for each pixel in the bin.
        Subtracted only here to avoid problems with integer arithmetic or 
        unnecessary conversions to float. Default: 0
    
    Returns
    -------
    Signal: numpy array
        Signal[n] gives the intensity of the neuron n.
    &#39;&#39;&#39;
    nNeuron = Neurons.shape[0]
    nCoord = Neurons.shape[1]
    
    if method==&#34;box&#34;:
        box_size = kwargs[&#39;box_size&#39;]
        nElements = np.prod(box_size)
        
        try: select_max = kwargs[&#39;select_max&#39;]
        except: select_max = False
        
        try: select_max_n = kwargs[&#39;select_max_n&#39;]
        except: select_max_n = 5
        
        if len(box_size)!=nCoord:
            print(&#34;Number of coordinates in Neuron coordinate and box_size &#34;+\
                &#34;don&#39;t match.&#34;)
            quit()

        # Generate indices for all the pixels in the boxes surrounding each neuron
        Indices = _generate_box_indices(Neurons, box_size, shape=Frames.shape)
        
        # Extract the values for each pixel
        Values = _slice_array(Frames,Indices).astype(np.float)-framePixelOffset
        
        # Reshape and sum values in each box
        Values = Values.reshape((nNeuron,nElements))
        np.clip(Values,0,None,Values)
        if not select_max:
            Signal = np.average(Values, axis=1)
        else:
            Signal = np.average(np.sort(Values,axis=1)[:,-select_max_n:],axis=1)
    
        return Signal
    elif method==&#34;weightedMask&#34;:
        weights = kwargs[&#39;weights&#39;]
        
        #hard coded indices - curvature extraction in neuronsegmentation-c
        nElements = 51
        Box = np.array([
            [-3,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,3],
            [0, -1,0,0,0,1, -2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2, -2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2, -2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2, -1,0,0,0,1, 0],
            [0,  0,1,0,1,0,  0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0,  0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0,  0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0,  0,1,0,1,0, 0]
            ])
            
        Box = []
        iz = -3
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,0])
        
        iz = -2
        Box.append([iz,-2,0])
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-2])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,0,2])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,1])
        Box.append([iz,2,0])
            
        for iz in np.array([-1,0,1]):
            Box.append([iz,-3,0])
            Box.append([iz,-2,-1])
            Box.append([iz,-2,0])
            Box.append([iz,-2,1])
            Box.append([iz,-1,-2])
            Box.append([iz,-1,-1])
            Box.append([iz,-1,0])
            Box.append([iz,-1,1])
            Box.append([iz,-1,2])
            Box.append([iz,0,-3])
            Box.append([iz,0,-2])
            Box.append([iz,0,-1])
            Box.append([iz,0,0])
            Box.append([iz,0,1])
            Box.append([iz,0,2])
            Box.append([iz,0,3])
            Box.append([iz,1,-2])
            Box.append([iz,1,-1])
            Box.append([iz,1,0])
            Box.append([iz,1,1])
            Box.append([iz,1,2])
            Box.append([iz,2,-1])
            Box.append([iz,2,0])
            Box.append([iz,2,1])
            Box.append([iz,3,0])
            
        iz = 2
        Box.append([iz,-2,0])
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-2])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,0,2])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,1])
        Box.append([iz,2,0])
        
        iz = 3
        Box.append([iz,-1,-1])
        Box.append([iz,-1,0])
        Box.append([iz,-1,1])
        Box.append([iz,0,-1])
        Box.append([iz,0,0])
        Box.append([iz,0,1])
        Box.append([iz,1,-1])
        Box.append([iz,1,0])
        Box.append([iz,1,0])
        
        Box = np.array(Box).T
        
        TM = np.zeros((119,51))
        TM[0:9,0] = 1.0
        TM[-9:,-1] = 1.0
        
        for sab in [[9,1],[9+13+25+25+25,1+5+13+13+13]]:
            sa = sab[0]
            sb = sab[1]
            TM[sa+0,sb+0] = 1.0
            TM[sa+1,sb+0] = TM[sa+1,sb+1] = TM[sa+1,sb+2] = 1./3.
            TM[sa+2,sb+0] = TM[sa+2,sb+2] = 0.5
            TM[sa+3,sb+0] = TM[sa+3,sb+2] = TM[sa+3,sb+3] = 1./3.0
            TM[sa+4,sb+1] = 1.0
            TM[sa+5,sb+1] = TM[sa+5,sb+2] = 0.5
            TM[sa+6,sb+2] = 1.0
            TM[sa+7,sb+2] = TM[sa+7,sb+3] = 0.5
            TM[sa+8,sb+3] = 1.0
            TM[sa+9,sb+1] = TM[sa+9,sb+2] = TM[sa+9,sb+4] = 1./3.
            TM[sa+10,sb+2] = TM[sa+10,sb+4] = 0.5
            TM[sa+11,sb+3] = TM[sa+11,sb+2] = TM[sa+11,sb+4] = 1./3.
            TM[sa+12,sb+4] = 1.0
        
        for sab in [[9+13,1+5],[9+13+25,1+5+13],[9+13+25+25,1+5+13+13]]:
            sa = sab[0]
            sb = sab[1]
            TM[sa+0,sb+0] = 1.0
            TM[sa+1,sb+0] = TM[sa+1,sb+1] = TM[sa+1,sb+2] = 1./3.
            TM[sa+2,sb+0] = TM[sa+2,sb+2] = 0.5
            TM[sa+3,sb+0] = TM[sa+3,sb+2] = TM[sa+3,sb+3] = 1./3.
            TM[sa+4,sb+1] = TM[sa+4,sb+4] = TM[sa+4,sb+5] = 1./3.
            TM[sa+5,sb+1] = TM[sa+5,sb+2] = TM[sa+5,sb+5] = TM[sa+5,sb+6] = 0.25
            TM[sa+6,sb+2] = TM[sa+6,sb+6] = 0.5
            TM[sa+7,sb+2] = TM[sa+7,sb+3] = TM[sa+7,sb+6] = TM[sa+7,sb+7] = 0.25
            TM[sa+8,sb+3] = TM[sa+8,sb+7] = TM[sa+8,sb+8] = 1./3.
            TM[sa+9,sb+4] = 1.0
            TM[sa+10,sb+4] = TM[sa+10,sb+5] = 0.5
            TM[sa+11,sb+5] = TM[sa+11,sb+6] = 0.5
            TM[sa+12,sb+6] = 1.0
            TM[sa+13,sb+6] = TM[sa+13,sb+7] = 0.5
            TM[sa+14,sb+7] = TM[sa+14,sb+8] = 0.5
            TM[sa+15,sb+8] = 1.0
            TM[sa+16,sb+4] = TM[sa+16,sb+5] = TM[sa+16,sb+9] = 1./3.
            TM[sa+17,sb+5] = TM[sa+17,sb+6] = TM[sa+17,sb+9] = TM[sa+17,sb+10] = 0.25
            TM[sa+18,sb+6] = TM[sa+17,sb+10] = 0.5
            TM[sa+19,sb+6] = TM[sa+19,sb+7] = TM[sa+19,sb+10] = TM[sa+19,sb+11] = 1./3.
            TM[sa+20,sb+7] = TM[sa+20,sb+8] = TM[sa+20,sb+11] = 1./3.
            TM[sa+21,sb+9] = TM[sa+21,sb+10] = TM[sa+21,sb+12] = 1./3.
            TM[sa+22,sb+10] = TM[sa+22,sb+12] = 0.5
            TM[sa+23,sb+10] = TM[sa+23,sb+11] = TM[sa+23,sb+12] = 1./3.
            TM[sa+24,sb+12] = 1.0
        
        weights_new = np.zeros((weights.shape[0],119))
        for qu in np.arange(weights.shape[0]):
            weights_new[qu] = np.dot(TM,weights[qu])
        
        weights = weights_new
        nElements = 119
        
        # Generate indices based on box
        Indices = _generate_box_indices(Neurons, Box=Box, shape=Frames.shape)
        
        # Extract the values for each pixel
        Values = _slice_array(Frames,Indices).astype(np.float)
        
        # Reshape, multiply by weights and sum values in each box
        Values = Values.reshape((nNeuron,nElements))-framePixelOffset
        np.clip(Values,0,None,Values)
        wValues = Values*weights
        wValues /= np.sum(weights,axis=1)[:,None]
        
        try:
            Signal = np.average(Values, axis=1)
        except:
            print(Neurons)
            print(Indices)
            print(Values)
        
        return Signal
        
    elif method==&#34;weightedMask2d&#34;:
        weights = kwargs[&#39;weights&#39;]
        
        #hard coded indices - curvature extraction in neuronsegmentation-c
        nElements = 13
        Box = np.array([
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [-2,-1,-1,-1,0,  0,0,0,0, 1,1,1,2],
            [0,-1, 0, 1,-2,-1,0,1,2,-1,0,1,0]
            ])
        
        # Generate indices based on box
        Indices = _generate_box_indices(Neurons, Box=Box, shape=Frames.shape)
        
        # Extract the values for each pixel
        Values = _slice_array(Frames,Indices).astype(np.float)
        
        # Reshape, multiply by weights and sum values in each box
        Values = Values.reshape((nNeuron,nElements))-framePixelOffset
        wValues = Values*weights
        wValues /= np.sum(weights,axis=1)[:,None]
        
        Signal = np.average(Values, axis=1) 
        
        return Signal
        
    elif method==&#34;fitSphere&#34;:
        # Doesn&#39;t really seem to help. Dropping it right now..
        
        # Right now this is fixed, it cannot be chosen
        box_size = (2,3,3)
        nElements = np.prod(box_size)
        
        # Generate indices based on box
        Indices = _generate_box_indices(Neurons, box_size)
        
        # Extract the values for each pixel, reshape, subtract camera offset
        Values = _slice_array(Frames,Indices).astype(np.float)
        Values = Values.reshape((nNeuron,nElements))-framePixelOffset
        
        # Calculate average signal at central plane and next one, to be used
        # to extract the radius of the neuron. Normalize them
        Y = np.empty((Values.shape[0],2))
        Y[:,0] = np.average(Values[:,0:9],axis=-1)
        Y[:,1] = np.average(Values[:,9:],axis=-1)
        
        Y[:,0] /= Y[:,0]
        Y[:,1] /= Y[:,1]
        
        # Calculate the radius of the neuron
        R = _sphere_radius(Y)
        
        # Extract signal and multiply by the radius
        Signal = np.average(Values[:,0:9], axis=1)*R
        
        return Signal
    
    else:
        print(&#34;Signal extraction method not implemented. See pp.signal.extract&#34;)
        quit()    </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#imports">Imports</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wormdatamodel.signal" href="index.html">wormdatamodel.signal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wormdatamodel.signal.extraction.extract" href="#wormdatamodel.signal.extraction.extract">extract</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>